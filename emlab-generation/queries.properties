"CapacityClearingPointPriceinEur", "DecarbonizationModel", "price = g.idx('__types__')[[className:'emlab.gen.domain.market.capacity.CapacityClearingPoint']].filter{it.time==tick}.price;
result=[]
for(p in price) result.add(p)
if(result.isEmpty()){return 0};
return result[0]",

"CapacityClearingPointVolumeinEur", "DecarbonizationModel", "volume = g.idx('__types__')[[className:'emlab.gen.domain.market.capacity.CapacityClearingPoint']].filter{it.time==tick}.volume;
result=[]
for(vl in volume) result.add(vl)
if(result.isEmpty()){return 0};
return result[0]",

"AnnualSRFraction", "ElectricitySpotMarket", "sum=0;
sum1=0;
ppdps = v.inE("BIDDINGMARKET").outV.filter{it.SRstatus<=-10 && it.status>=2 && it.time==tick};
for (ppdp in ppdps){
    totalAmount = ppdp.getProperty("acceptedAmount");
    hoursInSegment = ppdp.out("SEGMENT_DISPATCHPLAN").next().getProperty("lengthInHours");
    production = totalAmount * hoursInSegment;
    sum = sum + production;
}     
ppdpss = v.inE("BIDDINGMARKET").outV.filter{it.status>=2 && it.time==tick};   
for(pppdp in ppdpss){
    totalAmount1 = pppdp.getProperty("acceptedAmount");
    hoursInSegment1 = pppdp.out("SEGMENT_DISPATCHPLAN").next().getProperty("lengthInHours");
    production1 = totalAmount1 * hoursInSegment1;
    sum1 = sum1 + production1;
}
Fraction = sum/sum1;
return [v.name, Fraction]",

"SRCost", "StrategicReserveOperator", "cost = v.inE('FROM_AGENT').outV.filter{it.time==tick}.sum{it.money}
revenues = v.inE('TO_AGENT').outV.filter{it.time==tick}.sum{it.money}
zone = v.outE.inV.name
if (revenues == null){
    revenues = 0
}
return [v.name + ' Costs', cost];",

"SRProfits", "StrategicReserveOperator", "cost = v.inE('FROM_AGENT').outV.filter{it.time==tick}.sum{it.money}
revenues = v.inE('TO_AGENT').outV.filter{it.time==tick}.sum{it.money}
zone = v.outE.inV.name
if (revenues == null){
    revenues = 0
}
if(cost==null){
    cost=0
}
profit = revenues - cost
return [v.name + ' Profits', profit];",

"SRRevenue", "StrategicReserveOperator", "cost = v.inE('FROM_AGENT').outV.filter{it.time==tick}.sum{it.money}
revenues = v.inE('TO_AGENT').outV.filter{it.time==tick}.sum{it.money}
zone = v.outE.inV.name
if (revenues == null){
    revenues = 0
}
return [v.name + ' Revenue', revenues];",

"MaxSRVolumeDispatched", "ElectricitySpotMarket", "counter=0
markets = v
segments = v.outE('SEGMENT_LOAD').inV.outE('SEGMENTLOAD_SEGMENT').inV
for(market in markets){
    for(segment in segments){
        ppdps = segment.inE('SEGMENT_DISPATCHPLAN').outV.filter{it.SRstatus<=-10 && it.status>=2 && it.time==tick}.sum{it.acceptedAmount}
       if (ppdps > counter){
           counter = ppdps
       }
    }
}
return[markets.name, counter]",

"SRDispatchDuration", "ElectricitySpotMarket", "sum1=0;
prevseg=0;
markets = v;
ppdpss = v.inE("BIDDINGMARKET").outV.filter{it.SRstatus<=-10 && it.status>=2 && it.time==tick}.out("SEGMENT_DISPATCHPLAN").sort{it.segmentID}._().lengthInHours;
segs = v.inE("BIDDINGMARKET").outV.filter{it.SRstatus<=-10 && it.status>=2 && it.time==tick}.out("SEGMENT_DISPATCHPLAN").sort{it.segmentID}._();   
for (market in markets){
    currentMarket = market;
    for(seg in segs){
        if(seg.segmentID != prevseg && v==currentMarket){
            sum1=sum1+seg.getProperty("lengthInHours")
            prevseg=seg.segmentID            
        }             
    }
    return[v.name, sum1]
    
}",

"SRContractedVolume", "ElectricitySpotMarket", "markets = v
for (market in markets){   
    amounts = market.inE("BIDDINGMARKET").outV.filter{it.SRstatus<=-10 && it.time==tick}.amount.sum()
    if (amounts == null){
        amounts=0;
    }    
    reserve = amounts/20
    return[market.name, reserve]
}",

"SROperatorCashBalance", "StrategicReserveOperator", "[v.name, v.cash]",

"CapacityinMW", "PowerGeneratingTechnology", "capacity= v.in().filter{(it.dismantleTime > tick) && ((it.constructionStartTime + it.actualPermittime + it.actualLeadtime) <= tick)}.sum{it.actualNominalCapacity}
if(capacity == null) capacity = 0
[v.name, capacity]",

"CapacityinMWinA", "PowerGeneratingTechnology", "capacity = v.in('TECHNOLOGY').as('x').out('LOCATION').out('REGION').filter{it.name=='Country A'}.back('x').filter{(it.dismantleTime > tick) && ((it.constructionStartTime + it.actualPermittime + it.actualLeadtime) <= tick)}.sum{it.actualNominalCapacity}
if(capacity == null) capacity = 0
[v.name, capacity]",

"CapacityinMWinB", "PowerGeneratingTechnology", "capacity = v.in('TECHNOLOGY').as('x').out('LOCATION').out('REGION').filter{it.name=='Country B'}.back('x').filter{(it.dismantleTime > tick) && ((it.constructionStartTime + it.actualPermittime + it.actualLeadtime) <= tick)}.sum{it.actualNominalCapacity}
if(capacity == null) capacity = 0
[v.name, capacity]",

"BaseCostFip", "PowerGeneratingTechnology", "basecost = v.in('BASECOST_FOR_TECHNOLOGY').costPerMWh;
if(basecost == null) basecost = 0
[v.name, basecost]",


"PeakDemandPerZoneInMW", "ElectricitySpotMarket", "topsegments = v.out('SEGMENT_LOAD').max{it.baseLoad}.baseLoad;
try{growthfactors = v.out('DEMANDGROWTH_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){    
growthfactors=v.out('DEMANDGROWTH_TREND').timeSeries.next()[tick.toInteger()]}
adjustedTopSegments = topsegments*growthfactors;
return [v.outE('ZONE').inV.collect{it.name}[0], adjustedTopSegments]",

"TotalOperationalCapacityPerZoneInMW", "Zone", "t = new Table();
pp = v.in('REGION').in('LOCATION')
pp.filter{(it.dismantleTime > tick) && ((it.constructionStartTime + it.actualPermittime + it.actualLeadtime) <= tick)}.as('powerPlantCapacity').out('TECHNOLOGY').as('peakSegmentDependentAvailability').table(t){it.actualNominalCapacity}{it.peakSegmentDependentAvailability}.cap().next();
capacitySum = 0; for (row in t){capacitySum += row.getColumn('powerPlantCapacity') * row.getColumn('peakSegmentDependentAvailability')}
return [v.name, capacitySum]",

"TotalConsumptioninMWh", "DecarbonizationModel", "segmentloads = g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.SegmentLoad']];
productionsum  = 0;
for(segmentload in segmentloads){
    //productionsum += segmentload.baseLoad;
    try{growthfactor = segmentload.in('SEGMENT_LOAD').out('DEMANDGROWTH_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){
    growthfactor=segmentload.in('SEGMENT_LOAD').out('DEMANDGROWTH_TREND').timeSeries.next()[tick.toInteger()]}
    productionsum += segmentload.out('SEGMENTLOAD_SEGMENT').lengthInHours.next() * segmentload.baseLoad * growthfactor;
}
return productionsum;",

"SpotMarketCash", "ElectricitySpotMarket","return [v.name, v.cash];",

"GenerationinMWhCountryA", "PowerGeneratingTechnology", "sum = 0;
ppdps = v.in('TECHNOLOGY').as('x').out('LOCATION').out('REGION').filter{it.name=='Country A'}.back('x').in('POWERPLANT_DISPATCHPLAN').filter{it.time==tick && it.status>=2 && it.forecast==false};
for(ppdp in ppdps){
    totalAmount = ppdp.getProperty('acceptedAmount') + ppdp.getProperty('capacityLongTermContract');
    hoursInSegment = ppdp.out('SEGMENT_DISPATCHPLAN').next().getProperty('lengthInHours');
    production = totalAmount * hoursInSegment;
    sum = sum + production;
}
return [v.name, sum];
", 

"GenerationinMWhCountryB", "PowerGeneratingTechnology", "sum = 0;
ppdps = v.in('TECHNOLOGY').as('x').out('LOCATION').out('REGION').filter{it.name=='Country B'}.back('x').in('POWERPLANT_DISPATCHPLAN').filter{it.time==tick && it.status>=2 && it.forecast==false};
for(ppdp in ppdps){
    totalAmount = ppdp.getProperty('acceptedAmount') + ppdp.getProperty('capacityLongTermContract');
    hoursInSegment = ppdp.out('SEGMENT_DISPATCHPLAN').next().getProperty('lengthInHours');
    production = totalAmount * hoursInSegment;
    sum = sum + production;
}
return [v.name, sum];
", 

"GenerationinMWhPerProducer","EnergyProducer", "sum = 0;
ppdps = v.out('BIDDER').filter{it.__type__.contains('PowerPlantDispatchPlan')}.filter{it.time==tick && it.status>=2 && it.forecast==false};
for(ppdp in ppdps){
    totalAmount = ppdp.getProperty('acceptedAmount') + ppdp.getProperty('capacityLongTermContract');
    hoursInSegment = ppdp.out('SEGMENT_DISPATCHPLAN').next().getProperty('lengthInHours');
    production = totalAmount * hoursInSegment;
    sum = sum + production;
}
return [v.name, sum];",

"Avg_El_PricesinEURpMWh", "Zone", "cp = v.in('ZONE').in('MARKET_POINT').filter{it.time==tick  && it.forecast==false}.toList();
[v.name, cp.sum{it.price * it.volume} / cp.sum{it.volume}];
",

"Total_EnergyServedinMWh", "Zone", "cp = v.in('ZONE').in('MARKET_POINT').filter{it.time==tick && it.forecast==false};
return [v.name, cp.sum{it.volume}];
",

"Total_DemandinMWh", "Zone", "segmentloads = v.in('ZONE').out('SEGMENT_LOAD')
demandsum  = 0;
for(segmentload in segmentloads){
    try{growthfactor = segmentload.in('SEGMENT_LOAD').out('DEMANDGROWTH_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){  
    growthfactor=segmentload.in('SEGMENT_LOAD').out('DEMANDGROWTH_TREND').timeSeries.next()[tick.toInteger()]}    
    demandsum += segmentload.out('SEGMENTLOAD_SEGMENT').lengthInHours.next() * segmentload.baseLoad * growthfactor;
};
return [v.name, demandsum];
",



"WelfareLossThroughENS", "Zone", "cp = v.in('ZONE').in('MARKET_POINT').filter{it.time==tick && it.forecast==false}.toList();
energyServed = cp.sum{it.volume};
segmentloads = v.in('ZONE').out('SEGMENT_LOAD')
demandSum  = 0;
for(segmentload in segmentloads){
    try{growthfactor = segmentload.in('SEGMENT_LOAD').out('DEMANDGROWTH_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){  
    growthfactor=segmentload.in('SEGMENT_LOAD').out('DEMANDGROWTH_TREND').timeSeries.next()[tick.toInteger()]}    
    demandSum += segmentload.out('SEGMENTLOAD_SEGMENT').lengthInHours.next() * segmentload.baseLoad * growthfactor;
};
energyNotServed = demandSum - energyServed;
voll = v.in('ZONE').next().valueOfLostLoad
return [v.name, energyNotServed*voll];
",

"EnergyNotServedinMWh", "Zone", "cp = v.in('ZONE').in('MARKET_POINT').filter{it.time==tick && it.forecast==false}.toList();
energyServed = cp.sum{it.volume};
segmentloads = v.in('ZONE').out('SEGMENT_LOAD')
demandSum  = 0;
for(segmentload in segmentloads){
    try{growthfactor = segmentload.in('SEGMENT_LOAD').out('DEMANDGROWTH_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){  
    growthfactor=segmentload.in('SEGMENT_LOAD').out('DEMANDGROWTH_TREND').timeSeries.next()[tick.toInteger()]}    
    demandSum += segmentload.out('SEGMENTLOAD_SEGMENT').lengthInHours.next() * segmentload.baseLoad * growthfactor;
};
energyNotServed = demandSum - energyServed;
return [v.name, energyNotServed];
",

"FuelPricesPerGJ", "DecarbonizationModel", "fuels = g.idx('__types__')[[className:'emlab.gen.domain.technology.Substance']].filter{it.name != 'Electricity' && it.name != 'CO2'}
result = []
for(v in fuels){
      price = v.in('SUBSTANCE_MARKET').in('MARKET_POINT').filter{it.time == tick}.collect{it.price};
      density = v.energyDensity;
      inGJ = price[0] / density;
      result.add([v.name,inGJ]);}
      return result",

"ProducerCash", "EnergyProducer", "[v.name, v.cash]",

"HistoricalCVar", "PowerGeneratingTechnology", "fr = v.in('TECHNOLOGY').in('FINANCIALREPORT_POWERPLANT').propertyFilter('time', FilterPipe.Filter.GREATER_THAN_EQUAL, tick-2).propertyFilter('time', FilterPipe.Filter.LESS_THAN_EQUAL, tick).propertyFilter('powerPlantStatus', FilterPipe.Filter.EQUAL, 1);
cvar=0;
if(fr.hasNext()){fr=fr.sort{it.overallRevenue-it.variableCosts}._().toList();
length=fr.size(); fiveQuantile=(int)length*0.05;cvar=(long) 0;
for(int i=0; i<=fiveQuantile; i++){cvar=cvar+(fr[i].overallRevenue-fr[i].variableCosts)/fr[i].out('FINANCIALREPORT_POWERPLANT').actualNominalCapacity.next()};
cvar=cvar/((double)(fiveQuantile+1));}
return [v.name,cvar];",


"TABLE_SegmentClearingPoints", "DecarbonizationModel", "points = g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.SegmentClearingPoint']].propertyFilter('time', FilterPipe.Filter.EQUAL, tick).propertyFilter('forecast', FilterPipe.Filter.EQUAL, false)
finalResult = []
headers=['tick','volume','price','market','segmentID','segmentLength','interconectorFlow','demand','energynotserved']
finalResult.add(headers)
for(v in points){
market=v.out('MARKET_POINT')
segment=v.out('SEGMENT_POINT').next()
segmentId=segment.segmentID
segmentLoad=market.out('SEGMENT_LOAD').as('x').out('SEGMENTLOAD_SEGMENT').filter{it.segmentID==segmentId}.back('x').next();
//return segmentLoad.in('SEGMENT_LOAD').out('DEMANDGROWTH_TREND').timeSeries.next()[tick.toInteger()]
//return segmentLoad.in('SEGMENT_LOAD').out('DEMANDGROWTH_TREND').next().timeSeries[tick.toInteger()]
growthfactor=1
try{growthfactor = segmentLoad.in('SEGMENT_LOAD').out('DEMANDGROWTH_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){  
  growthfactor=segmentLoad.in('SEGMENT_LOAD').out('DEMANDGROWTH_TREND').next().timeSeries[tick.toInteger()]}
//}
//return segmentLoad
demandLevel=segmentLoad.out('SEGMENTLOAD_SEGMENT').lengthInHours.next() * segmentLoad.baseLoad * growthfactor;
    finalResult.add([v.time, v.volume, v.price, v.out('MARKET_POINT').collect{it.name}[0], v.out('SEGMENT_POINT').collect{it.segmentID}[0], v.out('SEGMENT_POINT').collect{it.lengthInHours}[0],v.interconnectorFlow,demandLevel,demandLevel-v.volume])
}
return finalResult;
",

"TABLE_ClearingPoints", "DecarbonizationModel", "points = g.idx('__types__')[[className:'emlab.gen.domain.market.ClearingPoint']].propertyFilter('time', FilterPipe.Filter.EQUAL, tick).propertyFilter('forecast', FilterPipe.Filter.EQUAL, false)
finalResult = []
headers=['tick','volume','price',',market']
finalResult.add(headers)
for(v in points){
finalResult.add([v.time, v.volume, v.price, v.out('MARKET_POINT').collect{it.name}[0]])
}
return finalResult",


"TABLE_FinancialReports", "DecarbonizationModel", "financialReports=g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.FinancialPowerPlantReport']].filter{it.time==tick};
finalResult = [];
columnNames=['tick', 'spotMarketRevenue', 'capacityMarketRevenue', 'strategicReserveRevenue', 'co2HedgingRevenue','fipRevenue', 'overallRevenue','commodityCosts','co2Costs','variableCosts','fixedCosts','fullLoadHours','production','powerPlantName','technology','location','powerPlantOwner','operationalStatus','firstYearOfPowerPlantOperation','nominalCapacity','investedCapital'];
finalResult.add(columnNames);
for(v in financialReports){
firstYearOfOperation=v.out('FINANCIALREPORT_POWERPLANT').constructionStartTime.next()+v.out('FINANCIALREPORT_POWERPLANT').actualPermittime.next()+v.out('FINANCIALREPORT_POWERPLANT').actualLeadtime.next()
powerPlantSize=v.out('FINANCIALREPORT_POWERPLANT').actualNominalCapacity.next()
actualInvestedCapital=v.out('FINANCIALREPORT_POWERPLANT').actualInvestedCapital.next()
finalResult.add([v.time, v.spotMarketRevenue, v.capacityMarketRevenue, v.strategicReserveRevenue, v.co2HedgingRevenue, v.feedInPremiumRevenue, v.overallRevenue, v.commodityCosts, v.co2Costs, v.variableCosts, v.fixedCosts, v.fullLoadHours, v.production, v.out('FINANCIALREPORT_POWERPLANT').name.next(),v.out('FINANCIALREPORT_POWERPLANT').out('TECHNOLOGY').name.next(),v.out('FINANCIALREPORT_POWERPLANT').out('LOCATION').name.next(),v.out('FINANCIALREPORT_POWERPLANT').out('POWERPLANT_OWNER').name.next(),v.powerPlantStatus,firstYearOfOperation,powerPlantSize,actualInvestedCapital]);
};
return finalResult;",

"CountryAProdFinances", "DecarbonizationModel", "flows = n.getNodes('CashFlow');
groups = flows.groupBy{it.type}
result = [];
totalCosts = 0;
totalRevenue = 0;
totalSpotRevenue = 0;
totalFipSubsidy=0;
for (key in groups.keySet()) {
       
     if (key==1) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country A')}[0]) {
                totalSpotRevenue += flow.money;
		totalRevenue += flow.money;
            } 
        }
        
    }

     if (key==3 || key==4 || key==7 || key==8) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('FROM_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('FROM_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country A')}[0]) {
                totalCosts += flow.money;
            } 
        }
        
    }

    
       
if (key==13) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country A')}[0]) {
                totalFipSubsidy += flow.money;
		totalRevenue += flow.money;
        }
        }

}
}
result.add(['Total Revenue', totalRevenue]);
result.add(['Total Costs', totalCosts]);
result.add(['Revenue Spot', totalSpotRevenue]);
result.add(['FIP Revenue', totalFipSubsidy]);
result.add(['Profit', totalRevenue - totalCosts]);
return result;
",

"CountryBProdFinances", "DecarbonizationModel", "flows = n.getNodes('CashFlow');
groups = flows.groupBy{it.type}
result = [];
totalCosts = 0;
totalRevenue = 0;
totalSpotRevenue = 0;
totalFipSubsidy=0;
for (key in groups.keySet()) {
       
     if (key==1) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country B')}[0]) {
                totalSpotRevenue += flow.money;
		totalRevenue += flow.money;
            } 
        }
        
    }

     if (key==3 || key==4 || key==7 || key==8) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('FROM_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('FROM_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country B')}[0]) {
                totalCosts += flow.money;
            } 
        }
        
    }

    
       
if (key==13) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country B')}[0]) {
                totalFipSubsidy += flow.money;
		totalRevenue += flow.money;
        }
        }

}
}
result.add(['Total Revenue', totalRevenue]);
result.add(['Total Costs', totalCosts]);
result.add(['Revenue Spot', totalSpotRevenue]);
result.add(['FIP Revenue', totalFipSubsidy]);
result.add(['Profit', totalRevenue - totalCosts]);
return result;
",



